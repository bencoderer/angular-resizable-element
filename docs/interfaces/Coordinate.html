<!doctype html>
<html class="no-js" lang="">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <title>angular-resizable-element documentation</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <link rel="icon" type="image/x-icon" href="../images/favicon.ico">
	   <link rel="stylesheet" href="../styles/style.css">
        <link rel="stylesheet" href="../styles/dark.css">
    </head>
    <body>

        <div class="navbar navbar-default navbar-fixed-top visible-xs">
            <a href="../" class="navbar-brand">angular-resizable-element documentation</a>
            <button type="button" class="btn btn-default btn-menu ion-ios-menu" id="btn-menu"></button>
        </div>

        <div class="xs-menu menu" id="mobile-menu">
                <div id="book-search-input" role="search"><input type="text" placeholder="Type to search"></div>            <compodoc-menu></compodoc-menu>
        </div>

        <div class="container-fluid main">
           <div class="row main">
               <div class="hidden-xs menu">
                   <compodoc-menu mode="normal"></compodoc-menu>
               </div>
               <!-- START CONTENT -->
               <div class="content interface">
                   <div class="content-data">













<ol class="breadcrumb">
  <li>Interfaces</li>
  <li
  >
  Coordinate</li>
</ol>

<ul class="nav nav-tabs" role="tablist">
        <li class="active">
            <a href="#info" role="tab" id="info-tab" data-toggle="tab" data-link="info">Info</a>
        </li>
        <li >
            <a href="#source" role="tab" id="source-tab" data-toggle="tab" data-link="source">Source</a>
        </li>
</ul>

<div class="tab-content">
    <div class="tab-pane fade active in" id="c-info">
        <p class="comment">
            <h3>File</h3>
        </p>
        <p class="comment">
            <code>projects/angular-resizable-element/src/lib/resizable.directive.ts</code>
        </p>




        <section>
            <h3 id="index">Index</h3>
            <table class="table table-sm table-bordered index-table">
                <tbody>
                    <tr>
                        <td class="col-md-4">
                            <h6><b>Properties</b></h6>
                        </td>
                    </tr>
                    <tr>
                        <td class="col-md-4">
                            <ul class="index-list">
                                <li>
                                        <a href="#x" 
>
                                            x
                                        </a>
                                </li>
                                <li>
                                        <a href="#y" 
>
                                            y
                                        </a>
                                </li>
                            </ul>
                        </td>
                    </tr>
                </tbody>
            </table>
        </section>



            <section>
                <h3 id="inputs">Properties</h3>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="x"></a>
                                        <span class="name "><b>x</b>
                                            <a href="#x">
                                                <span class="icon ion-ios-link"></span>
                                            </a>
                                        </span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>x:         <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/number" target="_blank" >number</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/number" target="_blank" >number</a></code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="y"></a>
                                        <span class="name "><b>y</b>
                                            <a href="#y">
                                                <span class="icon ion-ios-link"></span>
                                            </a>
                                        </span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>y:         <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/number" target="_blank" >number</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/number" target="_blank" >number</a></code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
            </section>
    </div>


    <div class="tab-pane fade  tab-source-code" id="c-source">
        <pre class="line-numbers compodoc-sourcecode"><code class="language-typescript">import {
  Directive,
  Renderer2,
  ElementRef,
  OnInit,
  Output,
  Input,
  EventEmitter,
  OnDestroy,
  NgZone,
  Inject,
  PLATFORM_ID,
} from &#x27;@angular/core&#x27;;
import { isPlatformBrowser } from &#x27;@angular/common&#x27;;
import { Subject, Observable, Observer, merge } from &#x27;rxjs&#x27;;
import {
  map,
  mergeMap,
  takeUntil,
  filter,
  pairwise,
  take,
  share,
  tap,
} from &#x27;rxjs/operators&#x27;;
import { Edges } from &#x27;./interfaces/edges.interface&#x27;;
import { BoundingRectangle } from &#x27;./interfaces/bounding-rectangle.interface&#x27;;
import { ResizeEvent } from &#x27;./interfaces/resize-event.interface&#x27;;
import { IS_TOUCH_DEVICE } from &#x27;./util/is-touch-device&#x27;;
import { deepCloneNode } from &#x27;./util/clone-node&#x27;;

interface PointerEventCoordinate {
  clientX: number;
  clientY: number;
  event: MouseEvent | TouchEvent;
}

interface Coordinate {
  x: number;
  y: number;
}

function getNewBoundingRectangle(
  startingRect: BoundingRectangle,
  edges: Edges,
  clientX: number,
  clientY: number
): BoundingRectangle {
  const newBoundingRect: BoundingRectangle &#x3D; {
    top: startingRect.top,
    bottom: startingRect.bottom,
    left: startingRect.left,
    right: startingRect.right,
  };

  if (edges.top) {
    newBoundingRect.top +&#x3D; clientY;
  }
  if (edges.bottom) {
    newBoundingRect.bottom +&#x3D; clientY;
  }
  if (edges.left) {
    newBoundingRect.left +&#x3D; clientX;
  }
  if (edges.right) {
    newBoundingRect.right +&#x3D; clientX;
  }
  newBoundingRect.height &#x3D; newBoundingRect.bottom - newBoundingRect.top;
  newBoundingRect.width &#x3D; newBoundingRect.right - newBoundingRect.left;

  return newBoundingRect;
}

function getElementRect(
  element: ElementRef,
  ghostElementPositioning: string
): BoundingRectangle {
  let translateX &#x3D; 0;
  let translateY &#x3D; 0;
  const style &#x3D; element.nativeElement.style;
  const transformProperties &#x3D; [
    &#x27;transform&#x27;,
    &#x27;-ms-transform&#x27;,
    &#x27;-moz-transform&#x27;,
    &#x27;-o-transform&#x27;,
  ];
  const transform &#x3D; transformProperties
    .map((property) &#x3D;&gt; style[property])
    .find((value) &#x3D;&gt; !!value);
  if (transform &amp;&amp; transform.includes(&#x27;translate&#x27;)) {
    translateX &#x3D; transform.replace(
      /.*translate3?d?\((-?[0-9]*)px, (-?[0-9]*)px.*/,
      &#x27;$1&#x27;
    );
    translateY &#x3D; transform.replace(
      /.*translate3?d?\((-?[0-9]*)px, (-?[0-9]*)px.*/,
      &#x27;$2&#x27;
    );
  }

  if (ghostElementPositioning &#x3D;&#x3D;&#x3D; &#x27;absolute&#x27;) {
    return {
      height: element.nativeElement.offsetHeight,
      width: element.nativeElement.offsetWidth,
      top: element.nativeElement.offsetTop - translateY,
      bottom:
        element.nativeElement.offsetHeight +
        element.nativeElement.offsetTop -
        translateY,
      left: element.nativeElement.offsetLeft - translateX,
      right:
        element.nativeElement.offsetWidth +
        element.nativeElement.offsetLeft -
        translateX,
    };
  } else {
    const boundingRect: BoundingRectangle &#x3D;
      element.nativeElement.getBoundingClientRect();
    return {
      height: boundingRect.height,
      width: boundingRect.width,
      top: boundingRect.top - translateY,
      bottom: boundingRect.bottom - translateY,
      left: boundingRect.left - translateX,
      right: boundingRect.right - translateX,
      scrollTop: element.nativeElement.scrollTop,
      scrollLeft: element.nativeElement.scrollLeft,
    };
  }
}

export interface ResizeCursors {
  topLeft: string;
  topRight: string;
  bottomLeft: string;
  bottomRight: string;
  leftOrRight: string;
  topOrBottom: string;
}

const DEFAULT_RESIZE_CURSORS: ResizeCursors &#x3D; Object.freeze({
  topLeft: &#x27;nw-resize&#x27;,
  topRight: &#x27;ne-resize&#x27;,
  bottomLeft: &#x27;sw-resize&#x27;,
  bottomRight: &#x27;se-resize&#x27;,
  leftOrRight: &#x27;col-resize&#x27;,
  topOrBottom: &#x27;row-resize&#x27;,
});

function getResizeCursor(edges: Edges, cursors: ResizeCursors): string {
  if (edges.left &amp;&amp; edges.top) {
    return cursors.topLeft;
  } else if (edges.right &amp;&amp; edges.top) {
    return cursors.topRight;
  } else if (edges.left &amp;&amp; edges.bottom) {
    return cursors.bottomLeft;
  } else if (edges.right &amp;&amp; edges.bottom) {
    return cursors.bottomRight;
  } else if (edges.left || edges.right) {
    return cursors.leftOrRight;
  } else if (edges.top || edges.bottom) {
    return cursors.topOrBottom;
  } else {
    return &#x27;&#x27;;
  }
}

function getEdgesDiff({
  edges,
  initialRectangle,
  newRectangle,
}: {
  edges: Edges;
  initialRectangle: BoundingRectangle;
  newRectangle: BoundingRectangle;
}): Edges {
  const edgesDiff: Edges &#x3D; {};
  Object.keys(edges).forEach((edge) &#x3D;&gt; {
    edgesDiff[edge] &#x3D; (newRectangle[edge] || 0) - (initialRectangle[edge] || 0);
  });
  return edgesDiff;
}

const RESIZE_ACTIVE_CLASS: string &#x3D; &#x27;resize-active&#x27;;
const RESIZE_GHOST_ELEMENT_CLASS: string &#x3D; &#x27;resize-ghost-element&#x27;;

export const MOUSE_MOVE_THROTTLE_MS: number &#x3D; 50;

/**
 * Place this on an element to make it resizable. For example:
 *
 * &#x60;&#x60;&#x60;html
 * &lt;div
 *   mwlResizable
 *   [resizeEdges]&#x3D;&quot;{bottom: true, right: true, top: true, left: true}&quot;
 *   [enableGhostResize]&#x3D;&quot;true&quot;&gt;
 * &lt;/div&gt;
 * &#x60;&#x60;&#x60;
 * Or in case they are sibling elements:
 * &#x60;&#x60;&#x60;html
 * &lt;div mwlResizable #resizableElement&#x3D;&quot;mwlResizable&quot;&gt;&lt;/div&gt;
 * &lt;div mwlResizeHandle [resizableContainer]&#x3D;&quot;resizableElement&quot; [resizeEdges]&#x3D;&quot;{bottom: true, right: true}&quot;&gt;&lt;/div&gt;
 * &#x60;&#x60;&#x60;
 */
@Directive({
  selector: &#x27;[mwlResizable]&#x27;,
  exportAs: &#x27;mwlResizable&#x27;,
})
export class ResizableDirective implements OnInit, OnDestroy {
  /**
   * A function that will be called before each resize event. Return &#x60;true&#x60; to allow the resize event to propagate or &#x60;false&#x60; to cancel it
   */
  @Input() validateResize: (resizeEvent: ResizeEvent) &#x3D;&gt; boolean;

  /**
   * Set to &#x60;true&#x60; to enable a temporary resizing effect of the element in between the &#x60;resizeStart&#x60; and &#x60;resizeEnd&#x60; events.
   */
  @Input() enableGhostResize: boolean &#x3D; false;

  /**
   * A snap grid that resize events will be locked to.
   *
   * e.g. to only allow the element to be resized every 10px set it to &#x60;{left: 10, right: 10}&#x60;
   */
  @Input() resizeSnapGrid: Edges &#x3D; {};

  /**
   * The mouse cursors that will be set on the resize edges
   */
  @Input() resizeCursors: Partial&lt;ResizeCursors&gt; &#x3D; DEFAULT_RESIZE_CURSORS;

  /**
   * Define the positioning of the ghost element (can be fixed or absolute)
   */
  @Input() ghostElementPositioning: &#x27;fixed&#x27; | &#x27;absolute&#x27; &#x3D; &#x27;fixed&#x27;;

  /**
   * Allow elements to be resized to negative dimensions
   */
  @Input() allowNegativeResizes: boolean &#x3D; false;

  /**
   * The mouse move throttle in milliseconds, default: 50 ms
   */
  @Input() mouseMoveThrottleMS: number &#x3D; MOUSE_MOVE_THROTTLE_MS;

  /**
   * Called when the mouse is pressed and a resize event is about to begin. &#x60;$event&#x60; is a &#x60;ResizeEvent&#x60; object.
   */
  @Output() resizeStart &#x3D; new EventEmitter&lt;ResizeEvent&gt;();

  /**
   * Called as the mouse is dragged after a resize event has begun. &#x60;$event&#x60; is a &#x60;ResizeEvent&#x60; object.
   */
  @Output() resizing &#x3D; new EventEmitter&lt;ResizeEvent&gt;();

  /**
   * Called after the mouse is released after a resize event. &#x60;$event&#x60; is a &#x60;ResizeEvent&#x60; object.
   */
  @Output() resizeEnd &#x3D; new EventEmitter&lt;ResizeEvent&gt;();

  /**
   * @hidden
   */
  public mouseup &#x3D; new Subject&lt;{
    clientX: number;
    clientY: number;
    edges?: Edges;
  }&gt;();

  /**
   * @hidden
   */
  public mousedown &#x3D; new Subject&lt;{
    clientX: number;
    clientY: number;
    edges?: Edges;
  }&gt;();

  /**
   * @hidden
   */
  public mousemove &#x3D; new Subject&lt;{
    clientX: number;
    clientY: number;
    edges?: Edges;
    event: MouseEvent | TouchEvent;
  }&gt;();

  private pointerEventListeners: PointerEventListeners;

  private destroy$ &#x3D; new Subject&lt;void&gt;();

  /**
   * @hidden
   */
  constructor(
    @Inject(PLATFORM_ID) private platformId: any,
    private renderer: Renderer2,
    public elm: ElementRef,
    private zone: NgZone
  ) {
    this.pointerEventListeners &#x3D; PointerEventListeners.getInstance(
      renderer,
      zone
    );
  }

  /**
   * @hidden
   */
  ngOnInit(): void {
    const mousedown$: Observable&lt;{
      clientX: number;
      clientY: number;
      edges?: Edges;
    }&gt; &#x3D; merge(this.pointerEventListeners.pointerDown, this.mousedown);

    const mousemove$ &#x3D; merge(
      this.pointerEventListeners.pointerMove,
      this.mousemove
    ).pipe(
      tap(({ event }) &#x3D;&gt; {
        if (currentResize) {
          try {
            event.preventDefault();
          } catch (e) {
            // just adding try-catch not to see errors in console if there is a passive listener for same event somewhere
            // browser does nothing except of writing errors to console
          }
        }
      }),
      share()
    );

    const mouseup$ &#x3D; merge(this.pointerEventListeners.pointerUp, this.mouseup);

    let currentResize: {
      edges: Edges;
      startingRect: BoundingRectangle;
      currentRect: BoundingRectangle;
      clonedNode?: HTMLElement;
    } | null;

    const removeGhostElement &#x3D; () &#x3D;&gt; {
      if (currentResize &amp;&amp; currentResize.clonedNode) {
        this.elm.nativeElement.parentElement.removeChild(
          currentResize.clonedNode
        );
        this.renderer.setStyle(this.elm.nativeElement, &#x27;visibility&#x27;, &#x27;inherit&#x27;);
      }
    };

    const getResizeCursors &#x3D; (): ResizeCursors &#x3D;&gt; {
      return {
        ...DEFAULT_RESIZE_CURSORS,
        ...this.resizeCursors,
      };
    };

    const mousedrag: Observable&lt;any&gt; &#x3D; mousedown$
      .pipe(
        mergeMap((startCoords) &#x3D;&gt; {
          function getDiff(moveCoords: { clientX: number; clientY: number }) {
            return {
              clientX: moveCoords.clientX - startCoords.clientX,
              clientY: moveCoords.clientY - startCoords.clientY,
            };
          }

          const getSnapGrid &#x3D; () &#x3D;&gt; {
            const snapGrid: Coordinate &#x3D; { x: 1, y: 1 };

            if (currentResize) {
              if (this.resizeSnapGrid.left &amp;&amp; currentResize.edges.left) {
                snapGrid.x &#x3D; +this.resizeSnapGrid.left;
              } else if (
                this.resizeSnapGrid.right &amp;&amp;
                currentResize.edges.right
              ) {
                snapGrid.x &#x3D; +this.resizeSnapGrid.right;
              }

              if (this.resizeSnapGrid.top &amp;&amp; currentResize.edges.top) {
                snapGrid.y &#x3D; +this.resizeSnapGrid.top;
              } else if (
                this.resizeSnapGrid.bottom &amp;&amp;
                currentResize.edges.bottom
              ) {
                snapGrid.y &#x3D; +this.resizeSnapGrid.bottom;
              }
            }

            return snapGrid;
          };

          function getGrid(
            coords: { clientX: number; clientY: number },
            snapGrid: Coordinate
          ) {
            return {
              x: Math.ceil(coords.clientX / snapGrid.x),
              y: Math.ceil(coords.clientY / snapGrid.y),
            };
          }

          return (
            merge(
              mousemove$.pipe(take(1)).pipe(map((coords) &#x3D;&gt; [, coords])),
              mousemove$.pipe(pairwise())
            ) as Observable&lt;
              [
                { clientX: number; clientY: number },
                { clientX: number; clientY: number }
              ]
            &gt;
          )
            .pipe(
              map(([previousCoords, newCoords]) &#x3D;&gt; {
                return [
                  previousCoords ? getDiff(previousCoords) : previousCoords,
                  getDiff(newCoords),
                ];
              })
            )
            .pipe(
              filter(([previousCoords, newCoords]) &#x3D;&gt; {
                if (!previousCoords) {
                  return true;
                }

                const snapGrid: Coordinate &#x3D; getSnapGrid();
                const previousGrid: Coordinate &#x3D; getGrid(
                  previousCoords,
                  snapGrid
                );
                const newGrid: Coordinate &#x3D; getGrid(newCoords, snapGrid);

                return (
                  previousGrid.x !&#x3D;&#x3D; newGrid.x || previousGrid.y !&#x3D;&#x3D; newGrid.y
                );
              })
            )
            .pipe(
              map(([, newCoords]) &#x3D;&gt; {
                const snapGrid: Coordinate &#x3D; getSnapGrid();
                return {
                  clientX:
                    Math.round(newCoords.clientX / snapGrid.x) * snapGrid.x,
                  clientY:
                    Math.round(newCoords.clientY / snapGrid.y) * snapGrid.y,
                };
              })
            )
            .pipe(takeUntil(merge(mouseup$, mousedown$)));
        })
      )
      .pipe(filter(() &#x3D;&gt; !!currentResize));

    mousedrag
      .pipe(
        map(({ clientX, clientY }) &#x3D;&gt; {
          return getNewBoundingRectangle(
            currentResize!.startingRect,
            currentResize!.edges,
            clientX,
            clientY
          );
        })
      )
      .pipe(
        filter((newBoundingRect: BoundingRectangle) &#x3D;&gt; {
          return (
            this.allowNegativeResizes ||
            !!(
              newBoundingRect.height &amp;&amp;
              newBoundingRect.width &amp;&amp;
              newBoundingRect.height &gt; 0 &amp;&amp;
              newBoundingRect.width &gt; 0
            )
          );
        })
      )
      .pipe(
        filter((newBoundingRect: BoundingRectangle) &#x3D;&gt; {
          return this.validateResize
            ? this.validateResize({
                rectangle: newBoundingRect,
                edges: getEdgesDiff({
                  edges: currentResize!.edges,
                  initialRectangle: currentResize!.startingRect,
                  newRectangle: newBoundingRect,
                }),
              })
            : true;
        }),
        takeUntil(this.destroy$)
      )
      .subscribe((newBoundingRect: BoundingRectangle) &#x3D;&gt; {
        if (currentResize &amp;&amp; currentResize.clonedNode) {
          this.renderer.setStyle(
            currentResize.clonedNode,
            &#x27;height&#x27;,
            &#x60;${newBoundingRect.height}px&#x60;
          );
          this.renderer.setStyle(
            currentResize.clonedNode,
            &#x27;width&#x27;,
            &#x60;${newBoundingRect.width}px&#x60;
          );
          this.renderer.setStyle(
            currentResize.clonedNode,
            &#x27;top&#x27;,
            &#x60;${newBoundingRect.top}px&#x60;
          );
          this.renderer.setStyle(
            currentResize.clonedNode,
            &#x27;left&#x27;,
            &#x60;${newBoundingRect.left}px&#x60;
          );
        }

        if (this.resizing.observers.length &gt; 0) {
          this.zone.run(() &#x3D;&gt; {
            this.resizing.emit({
              edges: getEdgesDiff({
                edges: currentResize!.edges,
                initialRectangle: currentResize!.startingRect,
                newRectangle: newBoundingRect,
              }),
              rectangle: newBoundingRect,
            });
          });
        }
        currentResize!.currentRect &#x3D; newBoundingRect;
      });

    mousedown$
      .pipe(
        map(({ edges }) &#x3D;&gt; {
          return edges || {};
        }),
        filter((edges: Edges) &#x3D;&gt; {
          return Object.keys(edges).length &gt; 0;
        }),
        takeUntil(this.destroy$)
      )
      .subscribe((edges: Edges) &#x3D;&gt; {
        if (currentResize) {
          removeGhostElement();
        }
        const startingRect: BoundingRectangle &#x3D; getElementRect(
          this.elm,
          this.ghostElementPositioning
        );
        currentResize &#x3D; {
          edges,
          startingRect,
          currentRect: startingRect,
        };
        const resizeCursors &#x3D; getResizeCursors();
        const cursor &#x3D; getResizeCursor(currentResize.edges, resizeCursors);
        this.renderer.setStyle(document.body, &#x27;cursor&#x27;, cursor);
        this.setElementClass(this.elm, RESIZE_ACTIVE_CLASS, true);
        if (this.enableGhostResize) {
          currentResize.clonedNode &#x3D; deepCloneNode(this.elm.nativeElement);
          this.elm.nativeElement.parentElement.appendChild(
            currentResize.clonedNode
          );
          this.renderer.setStyle(
            this.elm.nativeElement,
            &#x27;visibility&#x27;,
            &#x27;hidden&#x27;
          );
          this.renderer.setStyle(
            currentResize.clonedNode,
            &#x27;position&#x27;,
            this.ghostElementPositioning
          );
          this.renderer.setStyle(
            currentResize.clonedNode,
            &#x27;left&#x27;,
            &#x60;${currentResize.startingRect.left}px&#x60;
          );
          this.renderer.setStyle(
            currentResize.clonedNode,
            &#x27;top&#x27;,
            &#x60;${currentResize.startingRect.top}px&#x60;
          );
          this.renderer.setStyle(
            currentResize.clonedNode,
            &#x27;height&#x27;,
            &#x60;${currentResize.startingRect.height}px&#x60;
          );
          this.renderer.setStyle(
            currentResize.clonedNode,
            &#x27;width&#x27;,
            &#x60;${currentResize.startingRect.width}px&#x60;
          );
          this.renderer.setStyle(
            currentResize.clonedNode,
            &#x27;cursor&#x27;,
            getResizeCursor(currentResize.edges, resizeCursors)
          );
          this.renderer.addClass(
            currentResize.clonedNode,
            RESIZE_GHOST_ELEMENT_CLASS
          );
          currentResize.clonedNode!.scrollTop &#x3D; currentResize.startingRect
            .scrollTop as number;
          currentResize.clonedNode!.scrollLeft &#x3D; currentResize.startingRect
            .scrollLeft as number;
        }
        if (this.resizeStart.observers.length &gt; 0) {
          this.zone.run(() &#x3D;&gt; {
            this.resizeStart.emit({
              edges: getEdgesDiff({
                edges,
                initialRectangle: startingRect,
                newRectangle: startingRect,
              }),
              rectangle: getNewBoundingRectangle(startingRect, {}, 0, 0),
            });
          });
        }
      });

    mouseup$.pipe(takeUntil(this.destroy$)).subscribe(() &#x3D;&gt; {
      if (currentResize) {
        this.renderer.removeClass(this.elm.nativeElement, RESIZE_ACTIVE_CLASS);
        this.renderer.setStyle(document.body, &#x27;cursor&#x27;, &#x27;&#x27;);
        this.renderer.setStyle(this.elm.nativeElement, &#x27;cursor&#x27;, &#x27;&#x27;);
        if (this.resizeEnd.observers.length &gt; 0) {
          this.zone.run(() &#x3D;&gt; {
            this.resizeEnd.emit({
              edges: getEdgesDiff({
                edges: currentResize!.edges,
                initialRectangle: currentResize!.startingRect,
                newRectangle: currentResize!.currentRect,
              }),
              rectangle: currentResize!.currentRect,
            });
          });
        }
        removeGhostElement();
        currentResize &#x3D; null;
      }
    });
  }

  /**
   * @hidden
   */
  ngOnDestroy(): void {
    // browser check for angular universal, because it doesn&#x27;t know what document is
    if (isPlatformBrowser(this.platformId)) {
      this.renderer.setStyle(document.body, &#x27;cursor&#x27;, &#x27;&#x27;);
    }
    this.mousedown.complete();
    this.mouseup.complete();
    this.mousemove.complete();
    this.destroy$.next();
  }

  private setElementClass(elm: ElementRef, name: string, add: boolean): void {
    if (add) {
      this.renderer.addClass(elm.nativeElement, name);
    } else {
      this.renderer.removeClass(elm.nativeElement, name);
    }
  }
}

class PointerEventListeners {
  public pointerDown: Observable&lt;PointerEventCoordinate&gt;;

  public pointerMove: Observable&lt;PointerEventCoordinate&gt;;

  public pointerUp: Observable&lt;PointerEventCoordinate&gt;;

  private static instance: PointerEventListeners;

  public static getInstance(
    renderer: Renderer2,
    zone: NgZone
  ): PointerEventListeners {
    if (!PointerEventListeners.instance) {
      PointerEventListeners.instance &#x3D; new PointerEventListeners(
        renderer,
        zone
      );
    }
    return PointerEventListeners.instance;
  }

  constructor(renderer: Renderer2, zone: NgZone) {
    this.pointerDown &#x3D; new Observable(
      (observer: Observer&lt;PointerEventCoordinate&gt;) &#x3D;&gt; {
        let unsubscribeMouseDown: () &#x3D;&gt; void;
        let unsubscribeTouchStart: (() &#x3D;&gt; void) | undefined;

        zone.runOutsideAngular(() &#x3D;&gt; {
          unsubscribeMouseDown &#x3D; renderer.listen(
            &#x27;document&#x27;,
            &#x27;mousedown&#x27;,
            (event: MouseEvent) &#x3D;&gt; {
              observer.next({
                clientX: event.clientX,
                clientY: event.clientY,
                event,
              });
            }
          );

          if (IS_TOUCH_DEVICE) {
            unsubscribeTouchStart &#x3D; renderer.listen(
              &#x27;document&#x27;,
              &#x27;touchstart&#x27;,
              (event: TouchEvent) &#x3D;&gt; {
                observer.next({
                  clientX: event.touches[0].clientX,
                  clientY: event.touches[0].clientY,
                  event,
                });
              }
            );
          }
        });

        return () &#x3D;&gt; {
          unsubscribeMouseDown();
          if (IS_TOUCH_DEVICE) {
            unsubscribeTouchStart!();
          }
        };
      }
    ).pipe(share());

    this.pointerMove &#x3D; new Observable(
      (observer: Observer&lt;PointerEventCoordinate&gt;) &#x3D;&gt; {
        let unsubscribeMouseMove: () &#x3D;&gt; void;
        let unsubscribeTouchMove: (() &#x3D;&gt; void) | undefined;

        zone.runOutsideAngular(() &#x3D;&gt; {
          unsubscribeMouseMove &#x3D; renderer.listen(
            &#x27;document&#x27;,
            &#x27;mousemove&#x27;,
            (event: MouseEvent) &#x3D;&gt; {
              observer.next({
                clientX: event.clientX,
                clientY: event.clientY,
                event,
              });
            }
          );

          if (IS_TOUCH_DEVICE) {
            unsubscribeTouchMove &#x3D; renderer.listen(
              &#x27;document&#x27;,
              &#x27;touchmove&#x27;,
              (event: TouchEvent) &#x3D;&gt; {
                observer.next({
                  clientX: event.targetTouches[0].clientX,
                  clientY: event.targetTouches[0].clientY,
                  event,
                });
              }
            );
          }
        });

        return () &#x3D;&gt; {
          unsubscribeMouseMove();
          if (IS_TOUCH_DEVICE) {
            unsubscribeTouchMove!();
          }
        };
      }
    ).pipe(share());

    this.pointerUp &#x3D; new Observable(
      (observer: Observer&lt;PointerEventCoordinate&gt;) &#x3D;&gt; {
        let unsubscribeMouseUp: () &#x3D;&gt; void;
        let unsubscribeTouchEnd: (() &#x3D;&gt; void) | undefined;
        let unsubscribeTouchCancel: (() &#x3D;&gt; void) | undefined;

        zone.runOutsideAngular(() &#x3D;&gt; {
          unsubscribeMouseUp &#x3D; renderer.listen(
            &#x27;document&#x27;,
            &#x27;mouseup&#x27;,
            (event: MouseEvent) &#x3D;&gt; {
              observer.next({
                clientX: event.clientX,
                clientY: event.clientY,
                event,
              });
            }
          );

          if (IS_TOUCH_DEVICE) {
            unsubscribeTouchEnd &#x3D; renderer.listen(
              &#x27;document&#x27;,
              &#x27;touchend&#x27;,
              (event: TouchEvent) &#x3D;&gt; {
                observer.next({
                  clientX: event.changedTouches[0].clientX,
                  clientY: event.changedTouches[0].clientY,
                  event,
                });
              }
            );

            unsubscribeTouchCancel &#x3D; renderer.listen(
              &#x27;document&#x27;,
              &#x27;touchcancel&#x27;,
              (event: TouchEvent) &#x3D;&gt; {
                observer.next({
                  clientX: event.changedTouches[0].clientX,
                  clientY: event.changedTouches[0].clientY,
                  event,
                });
              }
            );
          }
        });

        return () &#x3D;&gt; {
          unsubscribeMouseUp();
          if (IS_TOUCH_DEVICE) {
            unsubscribeTouchEnd!();
            unsubscribeTouchCancel!();
          }
        };
      }
    ).pipe(share());
  }
}
</code></pre>
    </div>
</div>








                   </div><div class="search-results">
    <div class="has-results">
        <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
        <ul class="search-results-list"></ul>
    </div>
    <div class="no-results">
        <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
    </div>
</div>
</div>
               <!-- END CONTENT -->
           </div>
       </div>

          <label class="dark-mode-switch">
               <input type="checkbox">
               <span class="slider">
                    <svg class="slider-icon" viewBox="0 0 24 24" fill="none" height="20" stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" width="20" xmlns="http://www.w3.org/2000/svg">
                    <path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"></path>
                    </svg>
               </span>
          </label>

       <script>
            var COMPODOC_CURRENT_PAGE_DEPTH = 1;
            var COMPODOC_CURRENT_PAGE_CONTEXT = 'interface';
            var COMPODOC_CURRENT_PAGE_URL = 'Coordinate.html';
            var MAX_SEARCH_RESULTS = 15;
       </script>

       <script src="../js/libs/custom-elements.min.js"></script>
       <script src="../js/libs/lit-html.js"></script>

       <script src="../js/menu-wc.js" defer></script>
       <script nomodule src="../js/menu-wc_es5.js" defer></script>

       <script src="../js/libs/bootstrap-native.js"></script>

       <script src="../js/libs/es6-shim.min.js"></script>
       <script src="../js/libs/EventDispatcher.js"></script>
       <script src="../js/libs/promise.min.js"></script>
       <script src="../js/libs/zepto.min.js"></script>

       <script src="../js/compodoc.js"></script>

       <script src="../js/tabs.js"></script>
       <script src="../js/menu.js"></script>
       <script src="../js/libs/clipboard.min.js"></script>
       <script src="../js/libs/prism.js"></script>
       <script src="../js/sourceCode.js"></script>
          <script src="../js/search/search.js"></script>
          <script src="../js/search/lunr.min.js"></script>
          <script src="../js/search/search-lunr.js"></script>
          <script src="../js/search/search_index.js"></script>
       <script src="../js/lazy-load-graphs.js"></script>


    </body>
</html>
