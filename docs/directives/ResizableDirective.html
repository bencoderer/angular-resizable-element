<!doctype html>
<html class="no-js" lang="">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <title>angular-resizable-element documentation</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <link rel="icon" type="image/x-icon" href="../images/favicon.ico">
	      <link rel="stylesheet" href="../styles/style.css">
    </head>
    <body>

        <div class="navbar navbar-default navbar-fixed-top visible-xs">
            <a href="../" class="navbar-brand">angular-resizable-element documentation</a>
            <button type="button" class="btn btn-default btn-menu ion-ios-menu" id="btn-menu"></button>
        </div>

        <div class="xs-menu menu" id="mobile-menu">
                <div id="book-search-input" role="search"><input type="text" placeholder="Type to search"></div>            <compodoc-menu></compodoc-menu>
        </div>

        <div class="container-fluid main">
           <div class="row main">
               <div class="hidden-xs menu">
                   <compodoc-menu mode="normal"></compodoc-menu>
               </div>
               <!-- START CONTENT -->
               <div class="content directive">
                   <div class="content-data">






<ol class="breadcrumb">
  <li>Directives</li>
  <li>ResizableDirective</li>
</ol>

<ul class="nav nav-tabs" role="tablist">
        <li class="active">
            <a href="#info" role="tab" id="info-tab" data-toggle="tab" data-link="info">Info</a>
        </li>
        <li >
            <a href="#source" role="tab" id="source-tab" data-toggle="tab" data-link="source">Source</a>
        </li>
</ul>

<div class="tab-content">
    <div class="tab-pane fade active in" id="c-info">
        <p class="comment">
            <h3>File</h3>
        </p>
        <p class="comment">
            <code>src/resizable.directive.ts</code>
        </p>

            <p class="comment">
                <h3>Description</h3>
            </p>
            <p class="comment">
                <p>Place this on an element to make it resizable. For example:</p>
<div><pre class="line-numbers"><code class="language-html"> * &lt;div
 *   mwlResizable
 *   [resizeEdges]=&quot;{bottom: true, right: true, top: true, left: true}&quot;
 *   [enableGhostResize]=&quot;true&quot;&gt;
 * &lt;/div&gt;
 *</code></pre></div><p>Or in case they are sibling elements:</p>
<div><pre class="line-numbers"><code class="language-html"> * &lt;div mwlResizable #resizableElement=&quot;mwlResizable&quot;&gt;&lt;/div&gt;
 * &lt;div mwlResizeHandle [resizableContainer]=&quot;resizableElement&quot; [resizeEdges]=&quot;{bottom: true, right: true}&quot;&gt;&lt;/div&gt;
 *</code></pre></div>
            </p>

            <p class="comment">
                <h3>Implements</h3>
            </p>
            <p class="comment">
                        <code><a href="https://angular.io/api/core/OnInit" target="_blank" >OnInit</a></code>
                        <code><a href="https://angular.io/api/core/OnChanges" target="_blank" >OnChanges</a></code>
                        <code><a href="https://angular.io/api/core/OnDestroy" target="_blank" >OnDestroy</a></code>
            </p>


        <section>
            <h3>Metadata</h3>
            <table class="table table-sm table-hover">
                <tbody>

                    <tr>
                        <td class="col-md-3">Selector</td>
                        <td class="col-md-9"><code>[mwlResizable]</code></td>
                    </tr>

                </tbody>
            </table>
        </section>

            <section>
    <h3 id="index">Index</h3>
    <table class="table table-sm table-bordered index-table">
        <tbody>


                <tr>
                    <td class="col-md-4">
                        <h6><b>Inputs</b></h6>
                    </td>
                </tr>
                <tr>
                    <td class="col-md-4">
                        <ul class="index-list">
                            <li>
                                <a href="#allowNegativeResizes">allowNegativeResizes</a>
                            </li>
                            <li>
                                <a href="#enableGhostResize">enableGhostResize</a>
                            </li>
                            <li>
                                <a href="#ghostElementPositioning">ghostElementPositioning</a>
                            </li>
                            <li>
                                <a href="#mouseMoveThrottleMS">mouseMoveThrottleMS</a>
                            </li>
                            <li>
                                <a href="#resizeCursorPrecision">resizeCursorPrecision</a>
                            </li>
                            <li>
                                <a href="#resizeCursors">resizeCursors</a>
                            </li>
                            <li>
                                <a href="#resizeEdges">resizeEdges</a>
                            </li>
                            <li>
                                <a href="#resizeSnapGrid">resizeSnapGrid</a>
                            </li>
                            <li>
                                <a href="#validateResize">validateResize</a>
                            </li>
                        </ul>
                    </td>
                </tr>

                <tr>
                    <td class="col-md-4">
                        <h6><b>Outputs</b></h6>
                    </td>
                </tr>
                <tr>
                    <td class="col-md-4">
                        <ul class="index-list">
                            <li>
                                <a href="#resizeEnd">resizeEnd</a>
                            </li>
                            <li>
                                <a href="#resizeStart">resizeStart</a>
                            </li>
                            <li>
                                <a href="#resizing">resizing</a>
                            </li>
                        </ul>
                    </td>
                </tr>



        </tbody>
    </table>
</section>


            <section>
    <h3 id="inputs">Inputs</h3>
        <table class="table table-sm table-bordered">
            <tbody>
                <tr>
                    <td class="col-md-2">
                        <a name="allowNegativeResizes"></a>
                        <code>allowNegativeResizes</code>
                    </td>
                    <td class="col-md-10">
                        <div><p>Allow elements to be resized to negative dimensions</p>
</div>
                            <p>
                            <em>Type :</em>    <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/boolean" target="_blank" >boolean</a></code>

                            </p>
                        <p>
                            <em>Default value : </em><code>false</code>
                        </p>
                    </td>
                </tr>
                        <tr>
                            <td class="col-md-2" colspan="2">
                                    <div class="io-line">Defined in <a href="" data-line="339" class="link-to-prism">src/resizable.directive.ts:339</a></div>
                            </td>
                        </tr>
            </tbody>
        </table>
        <table class="table table-sm table-bordered">
            <tbody>
                <tr>
                    <td class="col-md-2">
                        <a name="enableGhostResize"></a>
                        <code>enableGhostResize</code>
                    </td>
                    <td class="col-md-10">
                        <div><p>Set to <code>true</code> to enable a temporary resizing effect of the element in between the <code>resizeStart</code> and <code>resizeEnd</code> events.</p>
</div>
                            <p>
                            <em>Type :</em>    <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/boolean" target="_blank" >boolean</a></code>

                            </p>
                        <p>
                            <em>Default value : </em><code>false</code>
                        </p>
                    </td>
                </tr>
                        <tr>
                            <td class="col-md-2" colspan="2">
                                    <div class="io-line">Defined in <a href="" data-line="311" class="link-to-prism">src/resizable.directive.ts:311</a></div>
                            </td>
                        </tr>
            </tbody>
        </table>
        <table class="table table-sm table-bordered">
            <tbody>
                <tr>
                    <td class="col-md-2">
                        <a name="ghostElementPositioning"></a>
                        <code>ghostElementPositioning</code>
                    </td>
                    <td class="col-md-10">
                        <div><p>Define the positioning of the ghost element (can be fixed or absolute)</p>
</div>
                            <p>
                            <em>Type :</em>    <code>&quot;fixed&quot; | &quot;absolute&quot;</code>

                            </p>
                        <p>
                            <em>Default value : </em><code>&#x27;fixed&#x27;</code>
                        </p>
                    </td>
                </tr>
                        <tr>
                            <td class="col-md-2" colspan="2">
                                    <div class="io-line">Defined in <a href="" data-line="334" class="link-to-prism">src/resizable.directive.ts:334</a></div>
                            </td>
                        </tr>
            </tbody>
        </table>
        <table class="table table-sm table-bordered">
            <tbody>
                <tr>
                    <td class="col-md-2">
                        <a name="mouseMoveThrottleMS"></a>
                        <code>mouseMoveThrottleMS</code>
                    </td>
                    <td class="col-md-10">
                        <div><p>The mouse move throttle in milliseconds, default: 50 ms</p>
</div>
                            <p>
                            <em>Type :</em>    <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/number" target="_blank" >number</a></code>

                            </p>
                        <p>
                            <em>Default value : </em><code>MOUSE_MOVE_THROTTLE_MS</code>
                        </p>
                    </td>
                </tr>
                        <tr>
                            <td class="col-md-2" colspan="2">
                                    <div class="io-line">Defined in <a href="" data-line="344" class="link-to-prism">src/resizable.directive.ts:344</a></div>
                            </td>
                        </tr>
            </tbody>
        </table>
        <table class="table table-sm table-bordered">
            <tbody>
                <tr>
                    <td class="col-md-2">
                        <a name="resizeCursorPrecision"></a>
                        <code>resizeCursorPrecision</code>
                    </td>
                    <td class="col-md-10">
                        <div><p>Mouse over thickness to active cursor.</p>
</div>
                            <p>
                            <em>Type :</em>    <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/number" target="_blank" >number</a></code>

                            </p>
                        <p>
                            <em>Default value : </em><code>3</code>
                        </p>
                    </td>
                </tr>
                        <tr>
                            <td class="col-md-2" colspan="2">
                                    <div class="io-line">Defined in <a href="" data-line="329" class="link-to-prism">src/resizable.directive.ts:329</a></div>
                            </td>
                        </tr>
            </tbody>
        </table>
        <table class="table table-sm table-bordered">
            <tbody>
                <tr>
                    <td class="col-md-2">
                        <a name="resizeCursors"></a>
                        <code>resizeCursors</code>
                    </td>
                    <td class="col-md-10">
                        <div><p>The mouse cursors that will be set on the resize edges</p>
</div>
                            <p>
                            <em>Type :</em>    <code><a href="../interfaces/ResizeCursors.html" target="_self" >ResizeCursors</a></code>

                            </p>
                        <p>
                            <em>Default value : </em><code>DEFAULT_RESIZE_CURSORS</code>
                        </p>
                    </td>
                </tr>
                        <tr>
                            <td class="col-md-2" colspan="2">
                                    <div class="io-line">Defined in <a href="" data-line="323" class="link-to-prism">src/resizable.directive.ts:323</a></div>
                            </td>
                        </tr>
            </tbody>
        </table>
        <table class="table table-sm table-bordered">
            <tbody>
                <tr>
                    <td class="col-md-2">
                        <a name="resizeEdges"></a>
                        <code>resizeEdges</code>
                    </td>
                    <td class="col-md-10">
                        <div><p>The edges that an element can be resized from. Pass an object like <code>{top: true, bottom: false}</code>. By default no edges can be resized.</p>
</div>
                            <p>
                            <em>Type :</em>    <code><a href="../interfaces/Edges.html" target="_self" >Edges</a></code>

                            </p>
                        <p>
                            <em>Default value : </em><code>{}</code>
                        </p>
                    </td>
                </tr>
                        <tr>
                            <td class="col-md-2" colspan="2">
                                    <div class="io-line">Defined in <a href="" data-line="306" class="link-to-prism">src/resizable.directive.ts:306</a></div>
                            </td>
                        </tr>
            </tbody>
        </table>
        <table class="table table-sm table-bordered">
            <tbody>
                <tr>
                    <td class="col-md-2">
                        <a name="resizeSnapGrid"></a>
                        <code>resizeSnapGrid</code>
                    </td>
                    <td class="col-md-10">
                        <div><p>A snap grid that resize events will be locked to.</p>
<p>e.g. to only allow the element to be resized every 10px set it to <code>{left: 10, right: 10}</code></p>
</div>
                            <p>
                            <em>Type :</em>    <code><a href="../interfaces/Edges.html" target="_self" >Edges</a></code>

                            </p>
                        <p>
                            <em>Default value : </em><code>{}</code>
                        </p>
                    </td>
                </tr>
                        <tr>
                            <td class="col-md-2" colspan="2">
                                    <div class="io-line">Defined in <a href="" data-line="318" class="link-to-prism">src/resizable.directive.ts:318</a></div>
                            </td>
                        </tr>
            </tbody>
        </table>
        <table class="table table-sm table-bordered">
            <tbody>
                <tr>
                    <td class="col-md-2">
                        <a name="validateResize"></a>
                        <code>validateResize</code>
                    </td>
                    <td class="col-md-10">
                        <div><p>A function that will be called before each resize event. Return <code>true</code> to allow the resize event to propagate or <code>false</code> to cancel it</p>
</div>
                            <p>
                            <em>Type :</em>    <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/function" target="_blank" >function</a></code>

                            </p>
                    </td>
                </tr>
                        <tr>
                            <td class="col-md-2" colspan="2">
                                    <div class="io-line">Defined in <a href="" data-line="300" class="link-to-prism">src/resizable.directive.ts:300</a></div>
                            </td>
                        </tr>
            </tbody>
        </table>
</section>
            <section>
    <h3 id="outputs">Outputs</h3>
        <table class="table table-sm table-bordered">
            <tbody>
                <tr>
                    <td class="col-md-2">
                        <a name="resizeEnd"></a>
                        <code>resizeEnd</code>
                    </td>
                    <td class="col-md-10">
                        <div><p>Called after the mouse is released after a resize event. <code>$event</code> is a <code>ResizeEvent</code> object.</p>
</div>
                        <em><code>$event</code> Type:</em>    <code><a href="https://angular.io/api/core/EventEmitter" target="_blank" >EventEmitter</a></code>

                    </td>
                </tr>
                        <tr>
                            <td class="col-md-2" colspan="2">
                                    <div class="io-line">Defined in <a href="" data-line="359" class="link-to-prism">src/resizable.directive.ts:359</a></div>
                            </td>
                        </tr>
            </tbody>
        </table>
        <table class="table table-sm table-bordered">
            <tbody>
                <tr>
                    <td class="col-md-2">
                        <a name="resizeStart"></a>
                        <code>resizeStart</code>
                    </td>
                    <td class="col-md-10">
                        <div><p>Called when the mouse is pressed and a resize event is about to begin. <code>$event</code> is a <code>ResizeEvent</code> object.</p>
</div>
                        <em><code>$event</code> Type:</em>    <code><a href="https://angular.io/api/core/EventEmitter" target="_blank" >EventEmitter</a></code>

                    </td>
                </tr>
                        <tr>
                            <td class="col-md-2" colspan="2">
                                    <div class="io-line">Defined in <a href="" data-line="349" class="link-to-prism">src/resizable.directive.ts:349</a></div>
                            </td>
                        </tr>
            </tbody>
        </table>
        <table class="table table-sm table-bordered">
            <tbody>
                <tr>
                    <td class="col-md-2">
                        <a name="resizing"></a>
                        <code>resizing</code>
                    </td>
                    <td class="col-md-10">
                        <div><p>Called as the mouse is dragged after a resize event has begun. <code>$event</code> is a <code>ResizeEvent</code> object.</p>
</div>
                        <em><code>$event</code> Type:</em>    <code><a href="https://angular.io/api/core/EventEmitter" target="_blank" >EventEmitter</a></code>

                    </td>
                </tr>
                        <tr>
                            <td class="col-md-2" colspan="2">
                                    <div class="io-line">Defined in <a href="" data-line="354" class="link-to-prism">src/resizable.directive.ts:354</a></div>
                            </td>
                        </tr>
            </tbody>
        </table>
</section>





    </div>


    <div class="tab-pane fade  tab-source-code" id="c-source">
        <pre class="line-numbers compodoc-sourcecode"><code class="language-typescript">import {
  Directive,
  Renderer2,
  ElementRef,
  OnInit,
  Output,
  Input,
  EventEmitter,
  OnDestroy,
  NgZone,
  OnChanges,
  SimpleChanges,
  Inject,
  PLATFORM_ID
} from &#x27;@angular/core&#x27;;
import { isPlatformBrowser } from &#x27;@angular/common&#x27;;
import { Subject, Observable, Observer, merge, EMPTY } from &#x27;rxjs&#x27;;
import {
  map,
  mergeMap,
  takeUntil,
  filter,
  pairwise,
  take,
  share,
  auditTime,
  switchMap,
  startWith,
  tap
} from &#x27;rxjs/operators&#x27;;
import { Edges } from &#x27;./interfaces/edges.interface&#x27;;
import { BoundingRectangle } from &#x27;./interfaces/bounding-rectangle.interface&#x27;;
import { ResizeEvent } from &#x27;./interfaces/resize-event.interface&#x27;;
import { IS_TOUCH_DEVICE } from &#x27;./is-touch-device&#x27;;

interface PointerEventCoordinate {
  clientX: number;
  clientY: number;
  event: MouseEvent | TouchEvent;
}

interface Coordinate {
  x: number;
  y: number;
}

function isNumberCloseTo(
  value1: number,
  value2: number,
  precision: number &#x3D; 3
): boolean {
  const diff: number &#x3D; Math.abs(value1 - value2);
  return diff &lt; precision;
}

function getNewBoundingRectangle(
  startingRect: BoundingRectangle,
  edges: Edges,
  clientX: number,
  clientY: number
): BoundingRectangle {
  const newBoundingRect: BoundingRectangle &#x3D; {
    top: startingRect.top,
    bottom: startingRect.bottom,
    left: startingRect.left,
    right: startingRect.right
  };

  if (edges.top) {
    newBoundingRect.top +&#x3D; clientY;
  }
  if (edges.bottom) {
    newBoundingRect.bottom +&#x3D; clientY;
  }
  if (edges.left) {
    newBoundingRect.left +&#x3D; clientX;
  }
  if (edges.right) {
    newBoundingRect.right +&#x3D; clientX;
  }
  newBoundingRect.height &#x3D; newBoundingRect.bottom - newBoundingRect.top;
  newBoundingRect.width &#x3D; newBoundingRect.right - newBoundingRect.left;

  return newBoundingRect;
}

function getElementRect(
  element: ElementRef,
  ghostElementPositioning: string
): BoundingRectangle {
  let translateX &#x3D; 0;
  let translateY &#x3D; 0;
  const style &#x3D; element.nativeElement.style;
  const transformProperties &#x3D; [
    &#x27;transform&#x27;,
    &#x27;-ms-transform&#x27;,
    &#x27;-moz-transform&#x27;,
    &#x27;-o-transform&#x27;
  ];
  const transform &#x3D; transformProperties
    .map(property &#x3D;&gt; style[property])
    .find(value &#x3D;&gt; !!value);
  if (transform &amp;&amp; transform.includes(&#x27;translate&#x27;)) {
    translateX &#x3D; transform.replace(
      /.*translate3?d?\((-?[0-9]*)px, (-?[0-9]*)px.*/,
      &#x27;$1&#x27;
    );
    translateY &#x3D; transform.replace(
      /.*translate3?d?\((-?[0-9]*)px, (-?[0-9]*)px.*/,
      &#x27;$2&#x27;
    );
  }

  if (ghostElementPositioning &#x3D;&#x3D;&#x3D; &#x27;absolute&#x27;) {
    return {
      height: element.nativeElement.offsetHeight,
      width: element.nativeElement.offsetWidth,
      top: element.nativeElement.offsetTop - translateY,
      bottom:
        element.nativeElement.offsetHeight +
        element.nativeElement.offsetTop -
        translateY,
      left: element.nativeElement.offsetLeft - translateX,
      right:
        element.nativeElement.offsetWidth +
        element.nativeElement.offsetLeft -
        translateX
    };
  } else {
    const boundingRect: BoundingRectangle &#x3D; element.nativeElement.getBoundingClientRect();
    return {
      height: boundingRect.height,
      width: boundingRect.width,
      top: boundingRect.top - translateY,
      bottom: boundingRect.bottom - translateY,
      left: boundingRect.left - translateX,
      right: boundingRect.right - translateX,
      scrollTop: element.nativeElement.scrollTop,
      scrollLeft: element.nativeElement.scrollLeft
    };
  }
}

function isWithinBoundingY({
  clientY,
  rect
}: {
  clientY: number;
  rect: ClientRect;
}): boolean {
  return clientY &gt;&#x3D; rect.top &amp;&amp; clientY &lt;&#x3D; rect.bottom;
}

function isWithinBoundingX({
  clientX,
  rect
}: {
  clientX: number;
  rect: ClientRect;
}): boolean {
  return clientX &gt;&#x3D; rect.left &amp;&amp; clientX &lt;&#x3D; rect.right;
}

function getResizeEdges({
  clientX,
  clientY,
  elm,
  allowedEdges,
  cursorPrecision
}: {
  clientX: number;
  clientY: number;
  elm: ElementRef;
  allowedEdges: Edges;
  cursorPrecision: number;
}): Edges {
  const elmPosition: ClientRect &#x3D; elm.nativeElement.getBoundingClientRect();
  const edges: Edges &#x3D; {};

  if (
    allowedEdges.left &amp;&amp;
    isNumberCloseTo(clientX, elmPosition.left, cursorPrecision) &amp;&amp;
    isWithinBoundingY({ clientY, rect: elmPosition })
  ) {
    edges.left &#x3D; true;
  }

  if (
    allowedEdges.right &amp;&amp;
    isNumberCloseTo(clientX, elmPosition.right, cursorPrecision) &amp;&amp;
    isWithinBoundingY({ clientY, rect: elmPosition })
  ) {
    edges.right &#x3D; true;
  }

  if (
    allowedEdges.top &amp;&amp;
    isNumberCloseTo(clientY, elmPosition.top, cursorPrecision) &amp;&amp;
    isWithinBoundingX({ clientX, rect: elmPosition })
  ) {
    edges.top &#x3D; true;
  }

  if (
    allowedEdges.bottom &amp;&amp;
    isNumberCloseTo(clientY, elmPosition.bottom, cursorPrecision) &amp;&amp;
    isWithinBoundingX({ clientX, rect: elmPosition })
  ) {
    edges.bottom &#x3D; true;
  }

  return edges;
}

export interface ResizeCursors {
  topLeft: string;
  topRight: string;
  bottomLeft: string;
  bottomRight: string;
  leftOrRight: string;
  topOrBottom: string;
}

const DEFAULT_RESIZE_CURSORS: ResizeCursors &#x3D; Object.freeze({
  topLeft: &#x27;nw-resize&#x27;,
  topRight: &#x27;ne-resize&#x27;,
  bottomLeft: &#x27;sw-resize&#x27;,
  bottomRight: &#x27;se-resize&#x27;,
  leftOrRight: &#x27;col-resize&#x27;,
  topOrBottom: &#x27;row-resize&#x27;
});

function getResizeCursor(edges: Edges, cursors: ResizeCursors): string {
  if (edges.left &amp;&amp; edges.top) {
    return cursors.topLeft;
  } else if (edges.right &amp;&amp; edges.top) {
    return cursors.topRight;
  } else if (edges.left &amp;&amp; edges.bottom) {
    return cursors.bottomLeft;
  } else if (edges.right &amp;&amp; edges.bottom) {
    return cursors.bottomRight;
  } else if (edges.left || edges.right) {
    return cursors.leftOrRight;
  } else if (edges.top || edges.bottom) {
    return cursors.topOrBottom;
  } else {
    return &#x27;&#x27;;
  }
}

function getEdgesDiff({
  edges,
  initialRectangle,
  newRectangle
}: {
  edges: Edges;
  initialRectangle: BoundingRectangle;
  newRectangle: BoundingRectangle;
}): Edges {
  const edgesDiff: Edges &#x3D; {};
  Object.keys(edges).forEach(edge &#x3D;&gt; {
    edgesDiff[edge] &#x3D; (newRectangle[edge] || 0) - (initialRectangle[edge] || 0);
  });
  return edgesDiff;
}

const RESIZE_ACTIVE_CLASS: string &#x3D; &#x27;resize-active&#x27;;
const RESIZE_LEFT_HOVER_CLASS: string &#x3D; &#x27;resize-left-hover&#x27;;
const RESIZE_RIGHT_HOVER_CLASS: string &#x3D; &#x27;resize-right-hover&#x27;;
const RESIZE_TOP_HOVER_CLASS: string &#x3D; &#x27;resize-top-hover&#x27;;
const RESIZE_BOTTOM_HOVER_CLASS: string &#x3D; &#x27;resize-bottom-hover&#x27;;
const RESIZE_GHOST_ELEMENT_CLASS: string &#x3D; &#x27;resize-ghost-element&#x27;;

export const MOUSE_MOVE_THROTTLE_MS: number &#x3D; 50;

/**
 * Place this on an element to make it resizable. For example:
 *
 * &#x60;&#x60;&#x60;html
 * &lt;div
 *   mwlResizable
 *   [resizeEdges]&#x3D;&quot;{bottom: true, right: true, top: true, left: true}&quot;
 *   [enableGhostResize]&#x3D;&quot;true&quot;&gt;
 * &lt;/div&gt;
 * &#x60;&#x60;&#x60;
 * Or in case they are sibling elements:
 * &#x60;&#x60;&#x60;html
 * &lt;div mwlResizable #resizableElement&#x3D;&quot;mwlResizable&quot;&gt;&lt;/div&gt;
 * &lt;div mwlResizeHandle [resizableContainer]&#x3D;&quot;resizableElement&quot; [resizeEdges]&#x3D;&quot;{bottom: true, right: true}&quot;&gt;&lt;/div&gt;
 * &#x60;&#x60;&#x60;
 */
@Directive({
  selector: &#x27;[mwlResizable]&#x27;,
  exportAs: &#x27;mwlResizable&#x27;
})
export class ResizableDirective implements OnInit, OnChanges, OnDestroy {
  /**
   * A function that will be called before each resize event. Return &#x60;true&#x60; to allow the resize event to propagate or &#x60;false&#x60; to cancel it
   */
  @Input() validateResize: (resizeEvent: ResizeEvent) &#x3D;&gt; boolean;

  /**
   * The edges that an element can be resized from. Pass an object like &#x60;{top: true, bottom: false}&#x60;. By default no edges can be resized.
   * @deprecated use a resize handle instead that positions itself to the side of the element you would like to resize
   */
  @Input() resizeEdges: Edges &#x3D; {};

  /**
   * Set to &#x60;true&#x60; to enable a temporary resizing effect of the element in between the &#x60;resizeStart&#x60; and &#x60;resizeEnd&#x60; events.
   */
  @Input() enableGhostResize: boolean &#x3D; false;

  /**
   * A snap grid that resize events will be locked to.
   *
   * e.g. to only allow the element to be resized every 10px set it to &#x60;{left: 10, right: 10}&#x60;
   */
  @Input() resizeSnapGrid: Edges &#x3D; {};

  /**
   * The mouse cursors that will be set on the resize edges
   */
  @Input() resizeCursors: ResizeCursors &#x3D; DEFAULT_RESIZE_CURSORS;

  /**
   * Mouse over thickness to active cursor.
   * @deprecated invalid when you migrate to use resize handles instead of setting resizeEdges on the element
   */
  @Input() resizeCursorPrecision: number &#x3D; 3;

  /**
   * Define the positioning of the ghost element (can be fixed or absolute)
   */
  @Input() ghostElementPositioning: &#x27;fixed&#x27; | &#x27;absolute&#x27; &#x3D; &#x27;fixed&#x27;;

  /**
   * Allow elements to be resized to negative dimensions
   */
  @Input() allowNegativeResizes: boolean &#x3D; false;

  /**
   * The mouse move throttle in milliseconds, default: 50 ms
   */
  @Input() mouseMoveThrottleMS: number &#x3D; MOUSE_MOVE_THROTTLE_MS;

  /**
   * Called when the mouse is pressed and a resize event is about to begin. &#x60;$event&#x60; is a &#x60;ResizeEvent&#x60; object.
   */
  @Output() resizeStart &#x3D; new EventEmitter&lt;ResizeEvent&gt;();

  /**
   * Called as the mouse is dragged after a resize event has begun. &#x60;$event&#x60; is a &#x60;ResizeEvent&#x60; object.
   */
  @Output() resizing &#x3D; new EventEmitter&lt;ResizeEvent&gt;();

  /**
   * Called after the mouse is released after a resize event. &#x60;$event&#x60; is a &#x60;ResizeEvent&#x60; object.
   */
  @Output() resizeEnd &#x3D; new EventEmitter&lt;ResizeEvent&gt;();

  /**
   * @hidden
   */
  public mouseup &#x3D; new Subject&lt;{
    clientX: number;
    clientY: number;
    edges?: Edges;
  }&gt;();

  /**
   * @hidden
   */
  public mousedown &#x3D; new Subject&lt;{
    clientX: number;
    clientY: number;
    edges?: Edges;
  }&gt;();

  /**
   * @hidden
   */
  public mousemove &#x3D; new Subject&lt;{
    clientX: number;
    clientY: number;
    edges?: Edges;
    event: MouseEvent | TouchEvent;
  }&gt;();

  private pointerEventListeners: PointerEventListeners;

  private destroy$ &#x3D; new Subject&lt;void&gt;();

  private resizeEdges$ &#x3D; new Subject&lt;Edges&gt;();

  /**
   * @hidden
   */
  constructor(
    @Inject(PLATFORM_ID) private platformId: any,
    private renderer: Renderer2,
    public elm: ElementRef,
    private zone: NgZone
  ) {
    this.pointerEventListeners &#x3D; PointerEventListeners.getInstance(
      renderer,
      zone
    );
  }

  /**
   * @hidden
   */
  ngOnInit(): void {
    const mousedown$: Observable&lt;{
      clientX: number;
      clientY: number;
      edges?: Edges;
    }&gt; &#x3D; merge(this.pointerEventListeners.pointerDown, this.mousedown);

    const mousemove$ &#x3D; merge(
      this.pointerEventListeners.pointerMove,
      this.mousemove
    ).pipe(
      tap(({ event }) &#x3D;&gt; {
        if (currentResize) {
          try {
            event.preventDefault();
          } catch (e) {
            // just adding try-catch not to see errors in console if there is a passive listener for same event somewhere
            // browser does nothing except of writing errors to console
          }
        }
      }),
      share()
    );

    const mouseup$ &#x3D; merge(this.pointerEventListeners.pointerUp, this.mouseup);

    let currentResize: {
      edges: Edges;
      startingRect: BoundingRectangle;
      currentRect: BoundingRectangle;
      clonedNode?: HTMLElement;
    } | null;

    const removeGhostElement &#x3D; () &#x3D;&gt; {
      if (currentResize &amp;&amp; currentResize.clonedNode) {
        this.elm.nativeElement.parentElement.removeChild(
          currentResize.clonedNode
        );
        this.renderer.setStyle(this.elm.nativeElement, &#x27;visibility&#x27;, &#x27;inherit&#x27;);
      }
    };

    const getResizeCursors &#x3D; (): ResizeCursors &#x3D;&gt; {
      return {
        ...DEFAULT_RESIZE_CURSORS,
        ...this.resizeCursors
      };
    };

    this.resizeEdges$
      .pipe(
        startWith(this.resizeEdges),
        map(() &#x3D;&gt; {
          return (
            this.resizeEdges &amp;&amp;
            Object.keys(this.resizeEdges).some(edge &#x3D;&gt; !!this.resizeEdges[edge])
          );
        }),
        switchMap(legacyResizeEdgesEnabled &#x3D;&gt;
          legacyResizeEdgesEnabled ? mousemove$ : EMPTY
        ),
        auditTime(this.mouseMoveThrottleMS),
        takeUntil(this.destroy$)
      )
      .subscribe(({ clientX, clientY }) &#x3D;&gt; {
        const resizeEdges: Edges &#x3D; getResizeEdges({
          clientX,
          clientY,
          elm: this.elm,
          allowedEdges: this.resizeEdges,
          cursorPrecision: this.resizeCursorPrecision
        });
        const resizeCursors &#x3D; getResizeCursors();
        if (!currentResize) {
          const cursor &#x3D; getResizeCursor(resizeEdges, resizeCursors);
          this.renderer.setStyle(this.elm.nativeElement, &#x27;cursor&#x27;, cursor);
        }
        this.setElementClass(
          this.elm,
          RESIZE_LEFT_HOVER_CLASS,
          resizeEdges.left &#x3D;&#x3D;&#x3D; true
        );
        this.setElementClass(
          this.elm,
          RESIZE_RIGHT_HOVER_CLASS,
          resizeEdges.right &#x3D;&#x3D;&#x3D; true
        );
        this.setElementClass(
          this.elm,
          RESIZE_TOP_HOVER_CLASS,
          resizeEdges.top &#x3D;&#x3D;&#x3D; true
        );
        this.setElementClass(
          this.elm,
          RESIZE_BOTTOM_HOVER_CLASS,
          resizeEdges.bottom &#x3D;&#x3D;&#x3D; true
        );
      });

    const mousedrag: Observable&lt;any&gt; &#x3D; mousedown$
      .pipe(
        mergeMap(startCoords &#x3D;&gt; {
          function getDiff(moveCoords: { clientX: number; clientY: number }) {
            return {
              clientX: moveCoords.clientX - startCoords.clientX,
              clientY: moveCoords.clientY - startCoords.clientY
            };
          }

          const getSnapGrid &#x3D; () &#x3D;&gt; {
            const snapGrid: Coordinate &#x3D; { x: 1, y: 1 };

            if (currentResize) {
              if (this.resizeSnapGrid.left &amp;&amp; currentResize.edges.left) {
                snapGrid.x &#x3D; +this.resizeSnapGrid.left;
              } else if (
                this.resizeSnapGrid.right &amp;&amp;
                currentResize.edges.right
              ) {
                snapGrid.x &#x3D; +this.resizeSnapGrid.right;
              }

              if (this.resizeSnapGrid.top &amp;&amp; currentResize.edges.top) {
                snapGrid.y &#x3D; +this.resizeSnapGrid.top;
              } else if (
                this.resizeSnapGrid.bottom &amp;&amp;
                currentResize.edges.bottom
              ) {
                snapGrid.y &#x3D; +this.resizeSnapGrid.bottom;
              }
            }

            return snapGrid;
          };

          function getGrid(
            coords: { clientX: number; clientY: number },
            snapGrid: Coordinate
          ) {
            return {
              x: Math.ceil(coords.clientX / snapGrid.x),
              y: Math.ceil(coords.clientY / snapGrid.y)
            };
          }

          return (merge(
            mousemove$.pipe(take(1)).pipe(map(coords &#x3D;&gt; [, coords])),
            mousemove$.pipe(pairwise())
          ) as Observable&lt;
            [
              { clientX: number; clientY: number },
              { clientX: number; clientY: number }
            ]
          &gt;)
            .pipe(
              map(([previousCoords, newCoords]) &#x3D;&gt; {
                return [
                  previousCoords ? getDiff(previousCoords) : previousCoords,
                  getDiff(newCoords)
                ];
              })
            )
            .pipe(
              filter(([previousCoords, newCoords]) &#x3D;&gt; {
                if (!previousCoords) {
                  return true;
                }

                const snapGrid: Coordinate &#x3D; getSnapGrid();
                const previousGrid: Coordinate &#x3D; getGrid(
                  previousCoords,
                  snapGrid
                );
                const newGrid: Coordinate &#x3D; getGrid(newCoords, snapGrid);

                return (
                  previousGrid.x !&#x3D;&#x3D; newGrid.x || previousGrid.y !&#x3D;&#x3D; newGrid.y
                );
              })
            )
            .pipe(
              map(([, newCoords]) &#x3D;&gt; {
                const snapGrid: Coordinate &#x3D; getSnapGrid();
                return {
                  clientX:
                    Math.round(newCoords.clientX / snapGrid.x) * snapGrid.x,
                  clientY:
                    Math.round(newCoords.clientY / snapGrid.y) * snapGrid.y
                };
              })
            )
            .pipe(takeUntil(merge(mouseup$, mousedown$)));
        })
      )
      .pipe(filter(() &#x3D;&gt; !!currentResize));

    mousedrag
      .pipe(
        map(({ clientX, clientY }) &#x3D;&gt; {
          return getNewBoundingRectangle(
            currentResize!.startingRect,
            currentResize!.edges,
            clientX,
            clientY
          );
        })
      )
      .pipe(
        filter((newBoundingRect: BoundingRectangle) &#x3D;&gt; {
          return (
            this.allowNegativeResizes ||
            !!(
              newBoundingRect.height &amp;&amp;
              newBoundingRect.width &amp;&amp;
              newBoundingRect.height &gt; 0 &amp;&amp;
              newBoundingRect.width &gt; 0
            )
          );
        })
      )
      .pipe(
        filter((newBoundingRect: BoundingRectangle) &#x3D;&gt; {
          return this.validateResize
            ? this.validateResize({
                rectangle: newBoundingRect,
                edges: getEdgesDiff({
                  edges: currentResize!.edges,
                  initialRectangle: currentResize!.startingRect,
                  newRectangle: newBoundingRect
                })
              })
            : true;
        }),
        takeUntil(this.destroy$)
      )
      .subscribe((newBoundingRect: BoundingRectangle) &#x3D;&gt; {
        if (currentResize &amp;&amp; currentResize.clonedNode) {
          this.renderer.setStyle(
            currentResize.clonedNode,
            &#x27;height&#x27;,
            &#x60;${newBoundingRect.height}px&#x60;
          );
          this.renderer.setStyle(
            currentResize.clonedNode,
            &#x27;width&#x27;,
            &#x60;${newBoundingRect.width}px&#x60;
          );
          this.renderer.setStyle(
            currentResize.clonedNode,
            &#x27;top&#x27;,
            &#x60;${newBoundingRect.top}px&#x60;
          );
          this.renderer.setStyle(
            currentResize.clonedNode,
            &#x27;left&#x27;,
            &#x60;${newBoundingRect.left}px&#x60;
          );
        }

        if (this.resizing.observers.length &gt; 0) {
          this.zone.run(() &#x3D;&gt; {
            this.resizing.emit({
              edges: getEdgesDiff({
                edges: currentResize!.edges,
                initialRectangle: currentResize!.startingRect,
                newRectangle: newBoundingRect
              }),
              rectangle: newBoundingRect
            });
          });
        }
        currentResize!.currentRect &#x3D; newBoundingRect;
      });

    mousedown$
      .pipe(
        map(({ clientX, clientY, edges }) &#x3D;&gt; {
          return (
            edges ||
            getResizeEdges({
              clientX,
              clientY,
              elm: this.elm,
              allowedEdges: this.resizeEdges,
              cursorPrecision: this.resizeCursorPrecision
            })
          );
        })
      )
      .pipe(
        filter((edges: Edges) &#x3D;&gt; {
          return Object.keys(edges).length &gt; 0;
        }),
        takeUntil(this.destroy$)
      )
      .subscribe((edges: Edges) &#x3D;&gt; {
        if (currentResize) {
          removeGhostElement();
        }
        const startingRect: BoundingRectangle &#x3D; getElementRect(
          this.elm,
          this.ghostElementPositioning
        );
        currentResize &#x3D; {
          edges,
          startingRect,
          currentRect: startingRect
        };
        const resizeCursors &#x3D; getResizeCursors();
        const cursor &#x3D; getResizeCursor(currentResize.edges, resizeCursors);
        this.renderer.setStyle(document.body, &#x27;cursor&#x27;, cursor);
        this.setElementClass(this.elm, RESIZE_ACTIVE_CLASS, true);
        if (this.enableGhostResize) {
          currentResize.clonedNode &#x3D; this.elm.nativeElement.cloneNode(true);
          this.elm.nativeElement.parentElement.appendChild(
            currentResize.clonedNode
          );
          this.renderer.setStyle(
            this.elm.nativeElement,
            &#x27;visibility&#x27;,
            &#x27;hidden&#x27;
          );
          this.renderer.setStyle(
            currentResize.clonedNode,
            &#x27;position&#x27;,
            this.ghostElementPositioning
          );
          this.renderer.setStyle(
            currentResize.clonedNode,
            &#x27;left&#x27;,
            &#x60;${currentResize.startingRect.left}px&#x60;
          );
          this.renderer.setStyle(
            currentResize.clonedNode,
            &#x27;top&#x27;,
            &#x60;${currentResize.startingRect.top}px&#x60;
          );
          this.renderer.setStyle(
            currentResize.clonedNode,
            &#x27;height&#x27;,
            &#x60;${currentResize.startingRect.height}px&#x60;
          );
          this.renderer.setStyle(
            currentResize.clonedNode,
            &#x27;width&#x27;,
            &#x60;${currentResize.startingRect.width}px&#x60;
          );
          this.renderer.setStyle(
            currentResize.clonedNode,
            &#x27;cursor&#x27;,
            getResizeCursor(currentResize.edges, resizeCursors)
          );
          this.renderer.addClass(
            currentResize.clonedNode,
            RESIZE_GHOST_ELEMENT_CLASS
          );
          currentResize.clonedNode!.scrollTop &#x3D; currentResize.startingRect
            .scrollTop as number;
          currentResize.clonedNode!.scrollLeft &#x3D; currentResize.startingRect
            .scrollLeft as number;
        }
        if (this.resizeStart.observers.length &gt; 0) {
          this.zone.run(() &#x3D;&gt; {
            this.resizeStart.emit({
              edges: getEdgesDiff({
                edges,
                initialRectangle: startingRect,
                newRectangle: startingRect
              }),
              rectangle: getNewBoundingRectangle(startingRect, {}, 0, 0)
            });
          });
        }
      });

    mouseup$.pipe(takeUntil(this.destroy$)).subscribe(() &#x3D;&gt; {
      if (currentResize) {
        this.renderer.removeClass(this.elm.nativeElement, RESIZE_ACTIVE_CLASS);
        this.renderer.setStyle(document.body, &#x27;cursor&#x27;, &#x27;&#x27;);
        this.renderer.setStyle(this.elm.nativeElement, &#x27;cursor&#x27;, &#x27;&#x27;);
        if (this.resizeEnd.observers.length &gt; 0) {
          this.zone.run(() &#x3D;&gt; {
            this.resizeEnd.emit({
              edges: getEdgesDiff({
                edges: currentResize!.edges,
                initialRectangle: currentResize!.startingRect,
                newRectangle: currentResize!.currentRect
              }),
              rectangle: currentResize!.currentRect
            });
          });
        }
        removeGhostElement();
        currentResize &#x3D; null;
      }
    });
  }

  /**
   * @hidden
   */
  ngOnChanges(changes: SimpleChanges): void {
    if (changes.resizeEdges) {
      this.resizeEdges$.next(this.resizeEdges);
    }
  }

  /**
   * @hidden
   */
  ngOnDestroy(): void {
    // browser check for angular universal, because it doesn&#x27;t know what document is
    if (isPlatformBrowser(this.platformId)) {
      this.renderer.setStyle(document.body, &#x27;cursor&#x27;, &#x27;&#x27;);
    }
    this.mousedown.complete();
    this.mouseup.complete();
    this.mousemove.complete();
    this.resizeEdges$.complete();
    this.destroy$.next();
  }

  private setElementClass(elm: ElementRef, name: string, add: boolean): void {
    if (add) {
      this.renderer.addClass(elm.nativeElement, name);
    } else {
      this.renderer.removeClass(elm.nativeElement, name);
    }
  }
}

class PointerEventListeners {
  public pointerDown: Observable&lt;PointerEventCoordinate&gt;;

  public pointerMove: Observable&lt;PointerEventCoordinate&gt;;

  public pointerUp: Observable&lt;PointerEventCoordinate&gt;;

  private static instance: PointerEventListeners; // tslint:disable-line

  public static getInstance(
    renderer: Renderer2,
    zone: NgZone
  ): PointerEventListeners {
    if (!PointerEventListeners.instance) {
      PointerEventListeners.instance &#x3D; new PointerEventListeners(
        renderer,
        zone
      );
    }
    return PointerEventListeners.instance;
  }

  constructor(renderer: Renderer2, zone: NgZone) {
    this.pointerDown &#x3D; new Observable(
      (observer: Observer&lt;PointerEventCoordinate&gt;) &#x3D;&gt; {
        let unsubscribeMouseDown: () &#x3D;&gt; void;
        let unsubscribeTouchStart: (() &#x3D;&gt; void) | undefined;

        zone.runOutsideAngular(() &#x3D;&gt; {
          unsubscribeMouseDown &#x3D; renderer.listen(
            &#x27;document&#x27;,
            &#x27;mousedown&#x27;,
            (event: MouseEvent) &#x3D;&gt; {
              observer.next({
                clientX: event.clientX,
                clientY: event.clientY,
                event
              });
            }
          );

          if (IS_TOUCH_DEVICE) {
            unsubscribeTouchStart &#x3D; renderer.listen(
              &#x27;document&#x27;,
              &#x27;touchstart&#x27;,
              (event: TouchEvent) &#x3D;&gt; {
                observer.next({
                  clientX: event.touches[0].clientX,
                  clientY: event.touches[0].clientY,
                  event
                });
              }
            );
          }
        });

        return () &#x3D;&gt; {
          unsubscribeMouseDown();
          if (IS_TOUCH_DEVICE) {
            unsubscribeTouchStart!();
          }
        };
      }
    ).pipe(share());

    this.pointerMove &#x3D; new Observable(
      (observer: Observer&lt;PointerEventCoordinate&gt;) &#x3D;&gt; {
        let unsubscribeMouseMove: () &#x3D;&gt; void;
        let unsubscribeTouchMove: (() &#x3D;&gt; void) | undefined;

        zone.runOutsideAngular(() &#x3D;&gt; {
          unsubscribeMouseMove &#x3D; renderer.listen(
            &#x27;document&#x27;,
            &#x27;mousemove&#x27;,
            (event: MouseEvent) &#x3D;&gt; {
              observer.next({
                clientX: event.clientX,
                clientY: event.clientY,
                event
              });
            }
          );

          if (IS_TOUCH_DEVICE) {
            unsubscribeTouchMove &#x3D; renderer.listen(
              &#x27;document&#x27;,
              &#x27;touchmove&#x27;,
              (event: TouchEvent) &#x3D;&gt; {
                observer.next({
                  clientX: event.targetTouches[0].clientX,
                  clientY: event.targetTouches[0].clientY,
                  event
                });
              }
            );
          }
        });

        return () &#x3D;&gt; {
          unsubscribeMouseMove();
          if (IS_TOUCH_DEVICE) {
            unsubscribeTouchMove!();
          }
        };
      }
    ).pipe(share());

    this.pointerUp &#x3D; new Observable(
      (observer: Observer&lt;PointerEventCoordinate&gt;) &#x3D;&gt; {
        let unsubscribeMouseUp: () &#x3D;&gt; void;
        let unsubscribeTouchEnd: (() &#x3D;&gt; void) | undefined;
        let unsubscribeTouchCancel: (() &#x3D;&gt; void) | undefined;

        zone.runOutsideAngular(() &#x3D;&gt; {
          unsubscribeMouseUp &#x3D; renderer.listen(
            &#x27;document&#x27;,
            &#x27;mouseup&#x27;,
            (event: MouseEvent) &#x3D;&gt; {
              observer.next({
                clientX: event.clientX,
                clientY: event.clientY,
                event
              });
            }
          );

          if (IS_TOUCH_DEVICE) {
            unsubscribeTouchEnd &#x3D; renderer.listen(
              &#x27;document&#x27;,
              &#x27;touchend&#x27;,
              (event: TouchEvent) &#x3D;&gt; {
                observer.next({
                  clientX: event.changedTouches[0].clientX,
                  clientY: event.changedTouches[0].clientY,
                  event
                });
              }
            );

            unsubscribeTouchCancel &#x3D; renderer.listen(
              &#x27;document&#x27;,
              &#x27;touchcancel&#x27;,
              (event: TouchEvent) &#x3D;&gt; {
                observer.next({
                  clientX: event.changedTouches[0].clientX,
                  clientY: event.changedTouches[0].clientY,
                  event
                });
              }
            );
          }
        });

        return () &#x3D;&gt; {
          unsubscribeMouseUp();
          if (IS_TOUCH_DEVICE) {
            unsubscribeTouchEnd!();
            unsubscribeTouchCancel!();
          }
        };
      }
    ).pipe(share());
  }
}
</code></pre>
    </div>

</div>












                   </div><div class="search-results">
    <div class="has-results">
        <h1 class="search-results-title"><span class='search-results-count'></span> result-matching "<span class='search-query'></span>"</h1>
        <ul class="search-results-list"></ul>
    </div>
    <div class="no-results">
        <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
    </div>
</div>
</div>
               <!-- END CONTENT -->
           </div>
       </div>

       <script>
            var COMPODOC_CURRENT_PAGE_DEPTH = 1;
            var COMPODOC_CURRENT_PAGE_CONTEXT = 'directive';
            var COMPODOC_CURRENT_PAGE_URL = 'ResizableDirective.html';
       </script>

       <script src="../js/libs/custom-elements.min.js"></script>
       <script src="../js/libs/lit-html.js"></script>
       <!-- Required to polyfill modern browsers as code is ES5 for IE... -->
       <script src="../js/libs/custom-elements-es5-adapter.js" charset="utf-8" defer></script>
       <script src="../js/menu-wc.js" defer></script>

       <script src="../js/libs/bootstrap-native.js"></script>

       <script src="../js/libs/es6-shim.min.js"></script>
       <script src="../js/libs/EventDispatcher.js"></script>
       <script src="../js/libs/promise.min.js"></script>
       <script src="../js/libs/zepto.min.js"></script>

       <script src="../js/compodoc.js"></script>

       <script src="../js/tabs.js"></script>
       <script src="../js/menu.js"></script>
       <script src="../js/libs/clipboard.min.js"></script>
       <script src="../js/libs/prism.js"></script>
       <script src="../js/sourceCode.js"></script>
          <script src="../js/search/search.js"></script>
          <script src="../js/search/lunr.min.js"></script>
          <script src="../js/search/search-lunr.js"></script>
          <script src="../js/search/search_index.js"></script>
       <script src="../js/lazy-load-graphs.js"></script>


    </body>
</html>
